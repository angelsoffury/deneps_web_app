{"version":3,"sources":["services.js"],"names":["trailingSlashes","Services","WebexPlugin","extend","namespace","registries","states","props","validateDomains","_catalogs","getRegistry","get","webex","getState","_getCatalog","name","priorityHost","serviceGroup","catalog","hasService","serviceName","hasAllowedDomains","getAllowedDomains","length","list","markFailedUrl","url","noPriorityHosts","updateServices","from","query","token","forceRefresh","formattedQuery","status","collecting","waitForCatalog","queryKey","includes","reject","Error","email","emailhash","toLowerCase","toString","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceUrls","updateCredentialsConfig","catch","error","validateUser","reqId","logger","info","canAuthorize","credentials","getUserToken","sendUserActivation","userObj","activated","exists","details","user","config","client_id","client_secret","collectPreauthCatalog","idbrokerService","getClientToken","uri","scope","tokenObj","collectSigninCatalog","rto","all","response","statusCode","responseText","body","message","fetchClientRegionInfo","request","addAuthHeader","headers","res","err","countryCode","timezone","clientRegionInfo","service","resource","method","accept","authorization","undefined","timeZone","shouldRefreshAccessToken","mode","idbroker","identity","authorizationString","authorizeUrl","replace","setConfig","timeout","supertoken","access_token","postauth","ready","preauth","initServiceCatalogs","waitForService","priorityUrl","priorityUrlObj","getServiceFromUrl","resolve","isReady","groupsToCheck","checkCatalog","catalogGroup","scopedPriorityUrl","scopedPrioriryUrlObj","map","group","_formatReceivedHostmap","serviceHostmap","formattedHostmap","hostCatalog","reduce","accumulator","key","id","split","defaultUrl","serviceLinks","serviceItem","find","item","defaultHost","Url","parse","hostname","hosts","push","host","ttl","priority","homeCluster","forEach","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","findServiceUrlFromUrl","isServiceUrl","isAllowedDomainUrl","findAllowedDomain","convertUrlToPriorityHostUrl","data","qs","format","timestamp","Date","getTime","requestObject","initConfig","services","discovery","formattedDiscoveryServices","override","formattedOverrideServices","allowedDomains","setAllowedDomains","getOrgId","orgId","warn","initialize","ServiceCatalog","registry","ServiceRegistry","state","ServiceState","set","listenToOnce"],"mappings":"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","sourcesContent":["import Url from 'url';\n\nimport sha256 from 'crypto-js/sha256';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport ServiceCatalog from './service-catalog';\nimport ServiceRegistry from './service-registry';\nimport ServiceState from './service-state';\n\n\nconst trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new WeakMap(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new WeakMap(),\n\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n\n  _catalogs: new WeakMap(),\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService(serviceName) {\n    return !!(this.get(serviceName));\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return (catalog.getAllowedDomains().length > 0);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({\n    from, query, token, forceRefresh\n  } = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n\n      if (queryKey === 'email' && query.email) {\n        formattedQuery.emailhash = sha256(query.email.toLowerCase()).toString();\n      }\n      else {\n        formattedQuery[queryKey] = query[queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery,\n      forceRefresh\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **Atlas** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({email, reqId = 'WEBCLIENT', forceRefresh = false}) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices({forceRefresh})\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => this.sendUserActivation({\n          email,\n          reqId,\n          token: token.toString()\n        }))\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error(\n        'client authentication details are not available'\n      ));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return this.collectPreauthCatalog({email})\n      .then(() => {\n        // Retrieve the service url from the updated catalog. This is required\n        // since `WebexCore` is usually not fully initialized at the time this\n        // request completes.\n        const idbrokerService = this.get('idbroker', true);\n\n        // Collect the client auth token.\n        return this.webex.credentials.getClientToken({\n          uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n          scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n        });\n      })\n      .then((tokenObj) => {\n        // Generate the token string.\n        token = tokenObj.toString();\n\n        // Collect the signin catalog using the client auth information.\n        return this.collectSigninCatalog({email, token, forceRefresh});\n      })\n      // Validate if collecting the signin catalog failed and populate the RTO\n      // with the appropriate content.\n      .catch((error) => ({\n        exists: (error.name !== 'NotFound'),\n        activated: false,\n        details: (error.name !== 'NotFound') ?\n          'user exists but is not activated' :\n          'user does not exist and is not activated'\n      }))\n      // Validate if the previous promise resolved with an RTO and populate the\n      // new RTO accordingly.\n      .then((rto) => Promise.all([\n        rto || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        },\n        this.sendUserActivation({email, reqId, token})\n      ]))\n      .then(([rto, user]) => ({...rto, user}))\n      .catch((error) => {\n        const response = {\n          statusCode: error.statusCode,\n          responseText: error.body && error.body.message,\n          body: error.body\n        };\n\n        return Promise.reject(response);\n      });\n  },\n\n  /**\n   * Fetches client region info such as countryCode and timezone.\n   *\n   * @returns {object} - The region info object.\n   */\n  fetchClientRegionInfo() {\n    return this.request({\n      uri: 'https://ds.ciscospark.com/v1/region',\n      addAuthHeader: false,\n      headers: {\n        'spark-user-agent': null\n      }\n    }).then((res) => {\n      this.logger.info('services: received user region info');\n\n      return res.body;\n    }).catch((err) => {\n      this.logger.info('services: was not able to get user region info', err);\n      // resolve successfully even if request failed\n    });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {AtlasDTO} - The DTO returned from the **Atlas** service.\n   */\n  sendUserActivation({email, reqId, token}) {\n    this.logger.info('services: sending user activation request');\n    let countryCode, timezone;\n\n\n    // try to fetch client region info first\n    return this.fetchClientRegionInfo()\n      .then((clientRegionInfo) => {\n        if (clientRegionInfo) {\n          ({countryCode, timezone} = clientRegionInfo);\n        }\n\n        // Send the user activation request to the **Atlas** service.\n        return this.request({\n          service: 'atlas',\n          resource: 'users/activations',\n          method: 'POST',\n          headers: {\n            accept: 'application/json',\n            authorization: token,\n            'x-prelogin-userid': undefined\n          },\n          body: {\n            email, reqId, countryCode, timeZone: timezone\n          },\n          shouldRefreshAccessToken: false\n        });\n      })\n      // On success, return the **Atlas** user object.\n      .then(({body}) => body)\n      // On failure, reject with error from **Atlas**.\n      .catch((error) => Promise.reject(error));\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @param {boolean} forceRefresh - Boolean to bypass u2c cache control header\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog(query, forceRefresh = false) {\n    if (!query) {\n      return this.updateServices({from: 'limited', query: {mode: 'DEFAULT_BY_PROXIMITY'}, forceRefresh});\n    }\n\n    return this.updateServices({from: 'limited', query, forceRefresh});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token, forceRefresh} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin', query: {email}, token, forceRefresh\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      const {authorizationString, authorizeUrl} = this.webex.config.credentials;\n\n      // This must be set outside of the setConfig method used to assign the\n      // idbroker and identity url values.\n      this.webex.config.credentials.authorizeUrl = authorizationString ?\n        authorizeUrl :\n        `${idbroker.replace(trailingSlashes, '')}/idb/oauth2/v1/authorize`;\n\n\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.replace(trailingSlashes, '') // remove trailing slash\n          },\n          identity: {\n            url: identity.replace(trailingSlashes, '') // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n    const {supertoken} = this.webex.credentials;\n\n    if (\n      serviceGroup === 'postauth' &&\n      supertoken &&\n      supertoken.access_token &&\n      !catalog.status.postauth.collecting &&\n      !catalog.status.postauth.ready\n    ) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    // Save memory by grabbing the catalog after there isn't a priortyURL\n    const catalog = this._getCatalog();\n\n    if (catalog.isReady) {\n      return url ?\n        Promise.resolve(url) :\n        Promise.reject(new Error(\n          `services: service '${name}' was not found in any of the catalogs`\n        ));\n    }\n\n    return new Promise((resolve, reject) => {\n      const groupsToCheck = ['limited', 'signin', 'postauth'];\n      const checkCatalog = (catalogGroup) =>\n        catalog.waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group)))\n        .then(() => {\n          reject(new Error(\n            `services: service '${name}' was not found after waiting`\n          ));\n        });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findAllowedDomain(url));\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({\n    from, query, token, forceRefresh\n  } = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    if (forceRefresh) {\n      qs.timestamp = new Date().getTime();\n    }\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig() {\n    // Get the catalog and destructure the services config.\n    const catalog = this._getCatalog();\n    const {services} = this.webex.config;\n\n    // Validate that the services configuration exists.\n    if (services) {\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        const formattedDiscoveryServices = Object.keys(services.discovery)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.discovery[key]\n          }));\n\n        // Inject formatted discovery services into services catalog.\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      }\n\n      if (services.override) {\n        // Format the override configuration into an injectable array.\n        const formattedOverrideServices = Object.keys(services.override)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.override[key]\n          }));\n\n        // Inject formatted override services into services catalog.\n        catalog.updateServiceUrls('override', formattedOverrideServices);\n      }\n\n      // Check for allowed host domains.\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      }\n\n      // Set `validateDomains` property to match configuration\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs() {\n    this.logger.info('services: initializing initial service catalogs');\n\n    // Destructure the credentials plugin.\n    const {credentials} = this.webex;\n\n    // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n    return Promise.resolve()\n      // Get the user's OrgId.\n      .then(() => credentials.getOrgId())\n      // Begin collecting the preauth/limited catalog.\n      .then((orgId) => this.collectPreauthCatalog({orgId}))\n      .then(() => {\n        // Validate if the token is authorized.\n        if (credentials.canAuthorize) {\n          // Attempt to collect the postauth catalog.\n          return this.updateServices()\n            .catch(() => this.logger.warn(\n              'services: cannot retrieve postauth catalog'\n            ));\n        }\n\n        // Return a resolved promise for consistent return value.\n        return Promise.resolve();\n      });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n    const registry = new ServiceRegistry();\n    const state = new ServiceState();\n\n    this._catalogs.set(this.webex, catalog);\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      this.initConfig();\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      const {supertoken} = this.webex.credentials;\n\n      // Validate if the supertoken exists.\n      if (supertoken && supertoken.access_token) {\n        this.initServiceCatalogs()\n          .then(() => {\n            catalog.isReady = true;\n          })\n          .catch((error) => this.logger.error(\n            `services: failed to init initial services, ${error.message}`\n          ));\n      }\n      else {\n        const {email} = this.webex.config;\n\n        this.collectPreauthCatalog(email ? {email} : undefined);\n      }\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"]}