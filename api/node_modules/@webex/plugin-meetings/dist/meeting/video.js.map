{"version":3,"sources":["video.js"],"names":["handleTransition","video","mute","self","MEETING_VIDEO_STATE_MACHINE","STATES","MUTE_SELF","UNMUTE_SELF","doToggle","transition","meeting","Media","setLocalTrack","mediaProperties","videoTrack","meetingAudio","audio","audioMuted","muted","MeetingUtil","remoteUpdateAudioVideo","then","locus","LoggerProxy","logger","log","event","from","to","catch","remoteUpdateError","reject","VideoStateMachine","create","mediaDirection","sendVideo","undefined","StateMachine","transitions","name","TRANSITIONS","TOGGLE","state","data","methods","isMuted","isSelf","setData","onBeforeToggle","locusInfo","onFullLocus","resolve","onAfterToggle","plugins","StateMachineHistory","max"],"mappings":"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","sourcesContent":["import StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {MEETING_VIDEO_STATE_MACHINE} from '../constants';\n\nconst handleTransition = (video) => {\n  if (video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n  if (!video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n\n  return null;\n};\n\nconst doToggle = (transition, video, meeting) => {\n  Media.setLocalTrack(!video.mute, meeting.mediaProperties.videoTrack);\n  const meetingAudio = meeting.audio;\n  const audioMuted = meetingAudio ? meetingAudio.muted : true;\n\n  return MeetingUtil.remoteUpdateAudioVideo(audioMuted, video.mute, meeting)\n    .then((locus) => {\n      LoggerProxy.logger.log(\n        `Meeting:video#doToggle --> VideoStateMachine->onAfterToggle#${transition.event} fired! State changed from '${transition.from}' to '${\n          transition.to\n        }' with transition '${transition.transition}''.`\n      );\n\n      return locus;\n    })\n    .catch((remoteUpdateError) => {\n      LoggerProxy.logger.log(\n        `Meeting:video#doToggle --> VideoStateMachine->onBeforeToggle#${transition.event} fired! State failed to change with transition '${\n          transition.transition\n        }''. After local Video toggle failed, resetting remote also failed, meeting video in bad state with error: ${remoteUpdateError}.`\n      );\n\n      return Promise.reject(remoteUpdateError);\n    });\n};\n\nconst VideoStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection object containing media direction\n   * @param {Boolean} mediaDirection.sendVideo Whether or not to send video in the meeting\n   * @param {Meeting} meeting an instance of a Meeting\n   * @returns {Statemachine} returns a state machine instance\n   */\n  create(mediaDirection, meeting) {\n    if (!mediaDirection.sendVideo) {\n      return undefined;\n    }\n\n    return new StateMachine({\n      transitions: [\n        {\n          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n          from: '*',\n          /**\n           *\n           * @param {Object} video current video data for the transition {mute, self}\n           * @returns {String} a new state value for the transition\n           */\n          to(video) {\n            return handleTransition(video) || this.state;\n          }\n        }\n      ],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience function to tell whether we are muted or not\n         * @returns {Boolen} boolean that indicates whether the video is currently muted\n         */\n        isMuted() {\n          return this.muted;\n        },\n        /**\n         * Convenience function to tell who last muted/unmuted the video\n         * @returns {Boolen} boolean that indicates whether the video was muted by the end user or server\n         */\n        isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} video current video options to set on the state machine\n         * @param {Boolean} video.mute indicates if video is muted or not for a meeting\n         * @param {Boolean} video.self indicates whether the end user or server muted the video\n         * @returns {null}\n         */\n        setData(video) {\n          this.muted = video.mute;\n          this.self = video.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n\n         * @param {Object} transition the StateMachine transition object\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle(transition, video) {\n          if (transition.from !== transition.to) {\n            return doToggle(transition, video, meeting)\n              .then((locus) => {\n                this.setData(video);\n                meeting.locusInfo.onFullLocus(locus);\n\n                return Promise.resolve(this.data);\n              });\n          }\n\n          return Promise.resolve(this.data);\n        },\n\n        /**\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle() {\n          return Promise.resolve(this.data);\n        },\n        plugins: [new StateMachineHistory({max: 5})]\n      }\n    });\n  }\n};\n\nexport default VideoStateMachine;\n"]}